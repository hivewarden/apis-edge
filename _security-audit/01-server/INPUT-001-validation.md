# INPUT-001: Input Validation Vulnerabilities

## Audit Metadata
- **Audit Date**: 2026-01-31
- **Auditor**: Security Audit (Automated)
- **Scope**: `/apis-server/internal/handlers/*.go`
- **Standard**: OWASP ASVS 4.0

---

## Executive Summary

This audit identified **10 input validation vulnerabilities** across the APIS server handler code. Issues range from HIGH severity (SSRF, command injection) to MEDIUM severity (missing length limits, unbounded arrays). The codebase demonstrates good practices in several areas (path traversal protection, enum validation) but has gaps in external URL handling and request body size limits.

---

## Finding 1: SSRF Vulnerability in Stream Handler

**Severity**: HIGH
**OWASP Category**: A10:2021 - Server-Side Request Forgery (SSRF)
**CWE**: CWE-918

### Vulnerable Code

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/stream.go`
**Lines**: 110-124

```go
// Connect to unit's MJPEG endpoint
// No timeout for MJPEG streaming - it's a continuous stream
unitURL := fmt.Sprintf("http://%s:8080/stream", *unit.IPAddress)
client := &http.Client{
    Timeout: 0, // No timeout for streaming
}

req, err := http.NewRequestWithContext(r.Context(), "GET", unitURL, nil)
if err != nil {
    log.Error().Err(err).Str("unit_id", unitID).Msg("handler: failed to create request to unit")
    ws.WriteMessage(websocket.TextMessage, []byte("Failed to connect to unit"))
    return
}

resp, err := client.Do(req)
```

### Attack Vector

The `unit.IPAddress` value is retrieved from the database without validation. If an attacker can compromise unit registration or update the IP address field in the database to an internal address (e.g., `127.0.0.1`, `169.254.169.254` for AWS metadata, `10.0.0.0/8` ranges), the server will make requests to internal services.

**Exploitation Scenario**:
1. Attacker registers a unit with a malicious IP address (if unit registration is compromised)
2. Or attacker exploits SQL injection elsewhere to modify a unit's `ip_address` field
3. Dashboard user views "live stream" for unit
4. Server makes HTTP request to attacker-controlled internal endpoint
5. AWS/GCP metadata, internal services, or local files may be exposed

### Remediation

```go
import "net"

// validateUnitIP checks if the IP address is safe for server-side requests
func validateUnitIP(ipStr string) error {
    ip := net.ParseIP(ipStr)
    if ip == nil {
        return fmt.Errorf("invalid IP address format")
    }

    // Block private ranges
    privateRanges := []string{
        "10.0.0.0/8",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "127.0.0.0/8",
        "169.254.0.0/16",  // Link-local / AWS metadata
        "::1/128",         // IPv6 localhost
        "fc00::/7",        // IPv6 unique local
        "fe80::/10",       // IPv6 link-local
    }

    for _, cidr := range privateRanges {
        _, network, _ := net.ParseCIDR(cidr)
        if network.Contains(ip) {
            return fmt.Errorf("private IP addresses not allowed")
        }
    }

    return nil
}

// In Stream handler:
if err := validateUnitIP(*unit.IPAddress); err != nil {
    http.Error(w, "Invalid unit IP address", http.StatusBadRequest)
    return
}
```

### Acceptance Criteria

- [ ] IP address validation rejects RFC 1918 private ranges
- [ ] IP address validation rejects localhost (127.0.0.0/8)
- [ ] IP address validation rejects link-local addresses (169.254.0.0/16)
- [ ] IP address validation rejects IPv6 private ranges
- [ ] Unit tests cover all blocked ranges
- [ ] Integration test confirms SSRF is prevented

---

## Finding 2: Command Injection in Transcribe Handler

**Severity**: HIGH
**OWASP Category**: A03:2021 - Injection
**CWE**: CWE-78

### Vulnerable Code

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/transcribe.go`
**Lines**: 287-294

```go
cmd := exec.Command("curl",
    "-s", // Silent
    "https://api.openai.com/v1/audio/transcriptions",
    "-H", "Authorization: Bearer "+apiKey,
    "-F", "file=@"+audioPath,
    "-F", "model=whisper-1",
    "-F", "response_format=text",
)
```

### Attack Vector

The `audioPath` variable is derived from a user-uploaded file's extension (line 102-106). While the temp file path is generated by the system, a malicious filename with shell metacharacters could potentially cause issues depending on the curl implementation and OS.

Additionally, at lines 228-234:
```go
ffmpegCmd := exec.Command("ffmpeg",
    "-i", audioPath,
    "-ar", "16000", // 16kHz sample rate
    "-ac", "1", // Mono
    "-y", // Overwrite
    wavPath,
)
```

While these paths are system-generated temp paths, the extension is derived from user input.

### Remediation

```go
// Sanitize file extension to prevent injection
func sanitizeExtension(filename string) string {
    ext := filepath.Ext(filename)
    // Only allow known safe extensions
    allowed := map[string]bool{
        ".webm": true, ".wav": true, ".mp3": true,
        ".ogg": true, ".mp4": true, ".m4a": true,
    }
    if allowed[strings.ToLower(ext)] {
        return ext
    }
    return ".webm" // Safe default
}

// In Transcribe handler:
ext := sanitizeExtension(header.Filename)
tempFile, err := os.CreateTemp("", "transcribe-*"+ext)
```

Also consider using the `http` package for OpenAI API calls instead of shelling out to curl.

### Acceptance Criteria

- [ ] File extensions are validated against an allowlist
- [ ] Shell metacharacters in filenames cannot affect command execution
- [ ] Replace curl shell-out with native HTTP client for OpenAI API
- [ ] Unit tests verify extension sanitization

---

## Finding 3: Missing Request Body Size Limits

**Severity**: MEDIUM
**OWASP Category**: A05:2021 - Security Misconfiguration
**CWE**: CWE-770

### Vulnerable Code

Multiple handlers decode JSON request bodies without size limits:

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/export.go`
**Lines**: 67-71

```go
var req ExportRequest
if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    respondError(w, "Invalid request body", http.StatusBadRequest)
    return
}
```

This pattern is repeated in:
- `sites.go` (CreateSite, UpdateSite)
- `units.go` (CreateUnit, UpdateUnit)
- `hives.go` (CreateHive, UpdateHive, ReplaceQueen)
- `inspections.go` (CreateInspection, UpdateInspection)
- `harvests.go` (CreateHarvest, UpdateHarvest)
- `treatments.go` (CreateTreatment, UpdateTreatment)
- `feedings.go` (CreateFeeding, UpdateFeeding)

### Attack Vector

An attacker can send extremely large JSON bodies (gigabytes) causing:
1. Memory exhaustion on the server
2. CPU exhaustion parsing huge JSON
3. Denial of Service

### Remediation

```go
const maxBodySize = 1 << 20 // 1MB - adjust per endpoint

// Apply to all handlers that read request bodies
func CreateSite(w http.ResponseWriter, r *http.Request) {
    r.Body = http.MaxBytesReader(w, r.Body, maxBodySize)

    var req CreateSiteRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        if err.Error() == "http: request body too large" {
            respondError(w, "Request body too large", http.StatusRequestEntityTooLarge)
            return
        }
        respondError(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    // ...
}
```

Or apply globally via middleware:

```go
func MaxBodySize(maxBytes int64) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            r.Body = http.MaxBytesReader(w, r.Body, maxBytes)
            next.ServeHTTP(w, r)
        })
    }
}
```

### Acceptance Criteria

- [ ] All JSON-accepting endpoints have body size limits
- [ ] Size limits are appropriate per endpoint (1MB default, higher for file uploads)
- [ ] Requests exceeding limit return 413 status code
- [ ] Load tests verify memory usage is bounded

---

## Finding 4: Unbounded Array Size in Batch Operations

**Severity**: MEDIUM
**OWASP Category**: A05:2021 - Security Misconfiguration
**CWE**: CWE-770

### Vulnerable Code

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/export.go`
**Lines**: 80-84

```go
// Validate hive selection
if len(req.HiveIDs) == 0 {
    respondError(w, "At least one hive must be selected", http.StatusBadRequest)
    return
}
```

No upper limit on `req.HiveIDs`. Similar issues in:

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/treatments.go`
**Lines**: 125-128

```go
if len(req.HiveIDs) == 0 {
    respondError(w, "At least one hive_id is required", http.StatusBadRequest)
    return
}
```

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/feedings.go`
**Lines**: 102-105

```go
if len(req.HiveIDs) == 0 {
    respondError(w, "At least one hive_id is required", http.StatusBadRequest)
    return
}
```

### Attack Vector

An attacker could send millions of hive IDs in a single request:
1. Server attempts to verify each hive exists (N database queries)
2. Server creates treatment/feeding records for each (N inserts)
3. Database connection pool exhaustion
4. Memory exhaustion storing array elements

### Remediation

```go
const maxBatchSize = 100

// In CreateTreatment, CreateFeeding, GenerateExport handlers:
if len(req.HiveIDs) == 0 {
    respondError(w, "At least one hive_id is required", http.StatusBadRequest)
    return
}
if len(req.HiveIDs) > maxBatchSize {
    respondError(w, fmt.Sprintf("Maximum %d hives per batch", maxBatchSize), http.StatusBadRequest)
    return
}
```

### Acceptance Criteria

- [ ] All batch operations have maximum array size limits
- [ ] Limits are documented in API documentation
- [ ] Requests exceeding limit return 400 with clear message
- [ ] Performance tests verify bounded resource usage

---

## Finding 5: Missing String Length Validation

**Severity**: MEDIUM
**OWASP Category**: A03:2021 - Injection
**CWE**: CWE-20

### Vulnerable Code

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/sites.go`
**Lines**: 132-137

```go
// Validate required fields
if req.Name == "" {
    respondError(w, "Name is required", http.StatusBadRequest)
    return
}
// No length limit on req.Name
```

Similar issues exist for:
- `sites.go`: Site name, timezone
- `units.go`: Unit name (serial has validation)
- `hives.go`: Hive name, notes
- `inspections.go`: Notes field (has 2000 char limit - good!)
- `harvests.go`: Notes field (no limit)
- `treatments.go`: Dose, notes
- `feedings.go`: Notes, concentration

### Attack Vector

1. Send extremely long strings (megabytes)
2. Database may truncate or error
3. Memory pressure during processing
4. Potential log injection if names are logged

### Remediation

```go
const (
    maxNameLength     = 255
    maxNotesLength    = 2000
    maxTimezoneLength = 64
)

// Validate name
if len(req.Name) > maxNameLength {
    respondError(w, fmt.Sprintf("Name must not exceed %d characters", maxNameLength), http.StatusBadRequest)
    return
}

// Use a helper function for consistency
func validateStringLength(field, value string, maxLen int) error {
    if len(value) > maxLen {
        return fmt.Errorf("%s must not exceed %d characters", field, maxLen)
    }
    return nil
}
```

### Acceptance Criteria

- [ ] All string fields have explicit length limits
- [ ] Limits match database column sizes
- [ ] Clear error messages indicate the limit
- [ ] Unit tests verify length validation

---

## Finding 6: Integer Overflow in Pagination

**Severity**: LOW
**OWASP Category**: A03:2021 - Injection
**CWE**: CWE-190

### Vulnerable Code

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/clips.go`
**Lines**: 374-391

```go
// Parse pagination
if page := r.URL.Query().Get("page"); page != "" {
    p, err := strconv.Atoi(page)
    if err != nil || p < 1 {
        respondError(w, "Invalid 'page' parameter", http.StatusBadRequest)
        return
    }
    params.Page = p  // Could be MaxInt
}

if perPage := r.URL.Query().Get("per_page"); perPage != "" {
    pp, err := strconv.Atoi(perPage)
    if err != nil || pp < 1 || pp > maxClipsPerPage {
        respondError(w, fmt.Sprintf("Invalid 'per_page' parameter (1-%d)", maxClipsPerPage), http.StatusBadRequest)
        return
    }
    params.PerPage = pp
}
```

While `per_page` has an upper limit, `page` does not. A page value of `MaxInt` could cause issues with OFFSET calculations:

```sql
OFFSET = (page - 1) * per_page
-- If page = 9223372036854775807 and per_page = 100
-- OFFSET = 922337203685477580600 (overflow)
```

### Attack Vector

1. Send `?page=9223372036854775807`
2. Database OFFSET calculation overflows
3. Undefined behavior or database error

### Remediation

```go
const maxPage = 10000  // Reasonable maximum page number

if page := r.URL.Query().Get("page"); page != "" {
    p, err := strconv.Atoi(page)
    if err != nil || p < 1 || p > maxPage {
        respondError(w, fmt.Sprintf("Invalid 'page' parameter (1-%d)", maxPage), http.StatusBadRequest)
        return
    }
    params.Page = p
}
```

### Acceptance Criteria

- [ ] All pagination parameters have both lower AND upper bounds
- [ ] Maximum page number prevents OFFSET overflow
- [ ] Error messages indicate valid range
- [ ] Database queries are tested with edge case values

---

## Finding 7: Missing Content-Type Validation

**Severity**: LOW
**OWASP Category**: A05:2021 - Security Misconfiguration
**CWE**: CWE-20

### Vulnerable Code

All JSON-accepting handlers decode request body without verifying Content-Type header:

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/sites.go`
**Lines**: 127-131

```go
var req CreateSiteRequest
if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
    respondError(w, "Invalid request body", http.StatusBadRequest)
    return
}
```

### Attack Vector

1. CSRF attacks may bypass some protections if Content-Type isn't checked
2. Browsers may pre-flight requests with certain Content-Types
3. Inconsistent behavior between form-encoded and JSON requests

### Remediation

Apply via middleware:

```go
func RequireJSON(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.Method == "POST" || r.Method == "PUT" || r.Method == "PATCH" {
            ct := r.Header.Get("Content-Type")
            if ct == "" || !strings.HasPrefix(ct, "application/json") {
                respondError(w, "Content-Type must be application/json", http.StatusUnsupportedMediaType)
                return
            }
        }
        next.ServeHTTP(w, r)
    })
}
```

### Acceptance Criteria

- [ ] All JSON endpoints require `application/json` Content-Type
- [ ] Invalid Content-Type returns 415 Unsupported Media Type
- [ ] Middleware applied to all API routes

---

## Finding 8: Incomplete UUID Validation

**Severity**: LOW
**OWASP Category**: A03:2021 - Injection
**CWE**: CWE-20

### Vulnerable Code

Path parameters are used directly without UUID format validation:

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/clips.go`
**Lines**: 436-443

```go
func GetClipThumbnail(w http.ResponseWriter, r *http.Request) {
    conn := storage.RequireConn(r.Context())
    clipID := chi.URLParam(r, "id")

    if clipID == "" {
        respondError(w, "Clip ID is required", http.StatusBadRequest)
        return
    }
    // No UUID format validation - proceeds to database query
```

This pattern is repeated across all handlers that accept `{id}` parameters.

### Attack Vector

1. Non-UUID values are passed to database queries
2. While parameterized queries prevent SQL injection, invalid UUIDs cause unnecessary database round-trips
3. Error messages may leak information about database schema

### Remediation

```go
import "github.com/google/uuid"

func validateUUID(id string) error {
    _, err := uuid.Parse(id)
    return err
}

// In handlers:
clipID := chi.URLParam(r, "id")
if clipID == "" {
    respondError(w, "Clip ID is required", http.StatusBadRequest)
    return
}
if err := validateUUID(clipID); err != nil {
    respondError(w, "Invalid clip ID format", http.StatusBadRequest)
    return
}
```

Or apply via Chi URL parameter validation middleware.

### Acceptance Criteria

- [ ] All ID parameters are validated as UUIDs before database queries
- [ ] Invalid UUIDs return 400 with generic message
- [ ] No database round-trip for invalid IDs

---

## Finding 9: Permissive WebSocket Origin Check

**Severity**: MEDIUM
**OWASP Category**: A01:2021 - Broken Access Control
**CWE**: CWE-346

### Vulnerable Code

**File**: `/Users/jermodelaruelle/Projects/apis/apis-server/internal/handlers/stream.go`
**Lines**: 27-34

```go
var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024 * 64, // 64KB for video frames
    CheckOrigin: func(r *http.Request) bool {
        // Allow all origins - auth is handled by JWT middleware
        return true
    },
}
```

### Attack Vector

1. Attacker hosts malicious page on attacker.com
2. User visits attacker.com while authenticated to APIS
3. Attacker's page opens WebSocket to APIS server
4. Browser includes authentication cookies/headers
5. Attacker receives live video stream from victim's units

### Remediation

```go
var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024 * 64,
    CheckOrigin: func(r *http.Request) bool {
        origin := r.Header.Get("Origin")
        allowedOrigins := []string{
            "https://apis.honeybeegood.be",
            "https://dashboard.apis.local",
        }
        // Also allow same-origin (no Origin header)
        if origin == "" {
            return true
        }
        for _, allowed := range allowedOrigins {
            if origin == allowed {
                return true
            }
        }
        return false
    },
}
```

### Acceptance Criteria

- [ ] WebSocket upgrade validates Origin header
- [ ] Allowed origins configured via environment variable
- [ ] Cross-origin WebSocket requests from unknown origins are rejected
- [ ] Test verifies malicious origins are blocked

---

## Finding 10: Missing Rate Limiting on Resource-Intensive Endpoints

**Severity**: MEDIUM
**OWASP Category**: A05:2021 - Security Misconfiguration
**CWE**: CWE-770

### Vulnerable Endpoints

The following endpoints perform expensive operations without specific rate limiting:

1. `POST /api/transcribe` - Runs ffmpeg and Whisper (CPU-intensive)
2. `POST /api/export` - Generates reports for multiple hives (database-intensive)
3. `GET /ws/stream/{id}` - Opens long-lived WebSocket connections
4. `POST /api/units/clips` - File upload and thumbnail generation

While the codebase has a general rate limiter in middleware, these endpoints need stricter limits.

### Remediation

```go
// Create endpoint-specific rate limiters
var (
    transcribeLimiter = rate.NewLimiter(rate.Every(time.Minute), 10)  // 10/min per IP
    exportLimiter     = rate.NewLimiter(rate.Every(time.Minute), 5)   // 5/min per user
    streamLimiter     = rate.NewLimiter(rate.Every(time.Second), 2)   // 2/sec per user
)

func TranscribeRateLimit(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if !transcribeLimiter.Allow() {
            respondError(w, "Too many transcription requests", http.StatusTooManyRequests)
            return
        }
        next.ServeHTTP(w, r)
    })
}
```

### Acceptance Criteria

- [ ] Transcribe endpoint limited to 10 requests/minute
- [ ] Export endpoint limited to 5 requests/minute
- [ ] Stream connections limited per user
- [ ] 429 response includes Retry-After header
- [ ] Load tests verify limits are enforced

---

## Positive Findings

The following good security practices were observed:

1. **Path Traversal Protection** (`clips.go:67-80`): The `ValidateFilePath` function properly prevents directory traversal attacks using `filepath.Clean` and prefix validation.

2. **Serial Number Validation** (`units.go:545-572`): The `isValidSerialFormat` function properly validates serial number format with length limits and character allowlist.

3. **Enum Validation**: Multiple handlers properly validate enum values:
   - Inspection fields (brood_pattern, honey_level, temperament)
   - Treatment types and methods
   - Feed types and units

4. **MP4 Format Validation** (`clips.go:173-177`): File uploads are validated for MP4 format.

5. **Coordinate Validation** (`sites.go:140-147`): GPS coordinates are validated for valid ranges.

6. **Notes Length Limit** (`inspections.go:223-228`): The notes field has a 2000 character limit.

7. **Timezone Validation** (`sites.go:301-308`): Timezone values are validated against the system IANA database.

---

## Summary

| Finding | Severity | Status |
|---------|----------|--------|
| SSRF in Stream Handler | HIGH | Open |
| Command Injection in Transcribe | HIGH | Open |
| Missing Request Body Size Limits | MEDIUM | Open |
| Unbounded Array Size | MEDIUM | Open |
| Missing String Length Validation | MEDIUM | Open |
| Integer Overflow in Pagination | LOW | Open |
| Missing Content-Type Validation | LOW | Open |
| Incomplete UUID Validation | LOW | Open |
| Permissive WebSocket Origin | MEDIUM | Open |
| Missing Rate Limiting | MEDIUM | Open |

**Priority Remediation Order**:
1. SSRF in Stream Handler (HIGH - External impact)
2. Command Injection in Transcribe (HIGH - Code execution)
3. WebSocket Origin Check (MEDIUM - CSRF risk)
4. Request Body Size Limits (MEDIUM - DoS)
5. Unbounded Array Size (MEDIUM - DoS)
6. Rate Limiting (MEDIUM - DoS)
7. String Length Validation (MEDIUM)
8. Pagination Overflow (LOW)
9. Content-Type Validation (LOW)
10. UUID Validation (LOW)
